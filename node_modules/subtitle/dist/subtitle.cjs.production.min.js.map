{"version":3,"file":"subtitle.cjs.production.min.js","sources":["../src/utils.ts","../src/formatTimestamp.ts","../src/map.ts","../src/Parser.ts","../src/parseTimestamp.ts","../src/parseTimestamps.ts","../src/Formatter.ts","../src/filter.ts","../src/parse.ts","../src/parseSync.ts","../src/resync.ts","../src/stringify.ts","../src/stringifySync.ts"],"sourcesContent":["import { Duplex, DuplexOptions } from 'readable-stream'\n\nexport const padLeft = (value: number, length = 2): string =>\n  value.toString().padStart(length, '0')\n\nexport const createDuplex = (options: DuplexOptions) =>\n  new Duplex({\n    objectMode: true,\n    read() {},\n    ...options\n  })\n","import { padLeft } from './utils'\nimport { FormatOptions } from '.'\n\nexport function formatTimestamp(\n  timestamp: number,\n  options: FormatOptions = { format: 'SRT' }\n) {\n  const date = new Date(0, 0, 0, 0, 0, 0, timestamp)\n\n  const hours = date.getHours()\n  const minutes = date.getMinutes()\n  const seconds = date.getSeconds()\n  const ms = Math.floor(\n    timestamp - (hours * 3600000 + minutes * 60000 + seconds * 1000)\n  )\n\n  return `${padLeft(hours)}:${padLeft(minutes)}:${padLeft(seconds)}${\n    options.format === 'WebVTT' ? '.' : ','\n  }${padLeft(ms, 3)}`\n}\n","import { Transform } from 'readable-stream'\nimport { Node } from '.'\n\nexport const map = (mapper: (node: Node, index: number) => any) => {\n  let index = 0\n\n  return new Transform({\n    objectMode: true,\n    transform(chunk: Node, _encoding, callback) {\n      callback(null, mapper(chunk, index++))\n    }\n  })\n}\n","import stripBom from 'strip-bom'\nimport { Node, RE_TIMESTAMP, parseTimestamps } from '.'\n\nexport type Pusher = (node: Node) => void\n\nexport interface ParseState {\n  expect: 'header' | 'id' | 'timestamp' | 'text' | 'vtt_comment'\n  row: number\n  hasContentStarted: boolean\n  isWebVTT: boolean\n  node: Partial<Node>\n  buffer: string[]\n}\n\nexport class Parser {\n  private push: Pusher\n  private state: ParseState\n\n  constructor({ push }: { push: Pusher }) {\n    this.push = push\n    this.state = {\n      expect: 'header',\n      row: 0,\n      hasContentStarted: false,\n      isWebVTT: false,\n      node: {},\n      buffer: []\n    }\n  }\n\n  private isIndex(line: string): boolean {\n    return /^\\d+$/.test(line.trim())\n  }\n\n  private isTimestamp(line: string): boolean {\n    return RE_TIMESTAMP.test(line)\n  }\n\n  private isVttComment(line: string): boolean {\n    return /^NOTE/.test(line)\n  }\n\n  private getError(expected: string, index: number, row: string): Error {\n    return new Error(\n      `expected ${expected} at row ${index + 1}, but received: \"${row}\"`\n    )\n  }\n\n  public parseLine(line: string): void {\n    const contents = this.state.row === 0 ? stripBom(line) : line\n\n    if (!this.state.hasContentStarted) {\n      if (contents.trim()) {\n        this.state.hasContentStarted = true\n      } else {\n        return\n      }\n    }\n\n    const parse = {\n      header: this.parseHeader,\n      id: this.parseId,\n      timestamp: this.parseTimestamp,\n      text: this.parseText,\n      vtt_comment: this.parseVttComment\n    }[this.state.expect]\n\n    parse.call(this, contents)\n\n    this.state.row++\n  }\n\n  public flush(): void {\n    if (this.state.buffer.length > 0) {\n      this.pushNode()\n    }\n  }\n\n  private parseHeader(line: string) {\n    if (!this.state.isWebVTT) {\n      this.state.isWebVTT = /^WEBVTT/.test(line)\n\n      if (this.state.isWebVTT) {\n        this.state.node.type = 'header'\n      } else {\n        this.parseId(line)\n        return\n      }\n    }\n\n    this.state.buffer.push(line)\n\n    if (!line) {\n      this.state.expect = 'id'\n      return\n    }\n  }\n\n  private parseId(line: string) {\n    this.state.expect = 'timestamp'\n\n    if (this.state.node.type === 'header') {\n      this.pushNode()\n    }\n\n    if (this.isIndex(line)) return\n\n    if (this.state.isWebVTT && this.isVttComment(line)) {\n      this.state.expect = 'vtt_comment'\n      return\n    }\n\n    this.parseTimestamp(line)\n  }\n\n  private parseVttComment(line: string) {\n    this.state.expect = 'vtt_comment'\n\n    if (line.trim() === '') {\n      this.state.expect = 'id'\n    }\n  }\n\n  private parseTimestamp(line: string) {\n    if (!this.isTimestamp(line)) {\n      throw this.getError('timestamp', this.state.row, line)\n    }\n\n    this.state.node = {\n      type: 'cue',\n      data: {\n        ...parseTimestamps(line),\n        text: ''\n      }\n    }\n\n    this.state.expect = 'text'\n  }\n\n  private parseText(line: string) {\n    if (this.state.buffer.length === 0) {\n      this.state.buffer.push(line)\n      return\n    }\n\n    if (this.isTimestamp(line)) {\n      const lastIndex = this.state.buffer.length - 1\n\n      if (this.isIndex(this.state.buffer[lastIndex])) {\n        this.state.buffer.pop()\n      }\n\n      this.pushNode()\n      this.parseTimestamp(line)\n      return\n    }\n\n    if (this.isVttComment(line)) {\n      this.pushNode()\n      this.parseVttComment(line)\n      return\n    }\n\n    this.state.buffer.push(line)\n  }\n\n  private pushNode(): void {\n    if (this.state.node.type === 'cue') {\n      while (true) {\n        const lastItem = this.state.buffer[this.state.buffer.length - 1]\n        if (['', '\\n'].includes(lastItem)) {\n          this.state.buffer.pop()\n        } else {\n          break\n        }\n      }\n\n      while (true) {\n        const firstItem = this.state.buffer[0]\n        if (['', '\\n'].includes(firstItem)) {\n          this.state.buffer.shift()\n        } else {\n          break\n        }\n      }\n\n      this.state.node.data!.text = this.state.buffer.join('\\n')\n    }\n\n    if (this.state.node.type === 'header') {\n      this.state.node.data = this.state.buffer.join('\\n').trim()\n    }\n\n    this.push(this.state.node as Node)\n\n    this.state.node = {}\n    this.state.buffer = []\n  }\n}\n","export function parseTimestamp(timestamp: string): number {\n  const match = timestamp.match(\n    /^(?:(\\d{1,}):)?(\\d{1,2}):(\\d{1,2})[,.](\\d{1,3})$/\n  )\n\n  if (!match) {\n    throw new Error('Invalid SRT or VTT time format: \"' + timestamp + '\"')\n  }\n\n  const hours = match[1] ? parseInt(match[1], 10) * 3600000 : 0\n  const minutes = parseInt(match[2], 10) * 60000\n  const seconds = parseInt(match[3], 10) * 1000\n  const milliseconds = parseInt(match[4], 10)\n\n  return hours + minutes + seconds + milliseconds\n}\n","import { parseTimestamp, Timestamp } from '.'\n\nexport const RE_TIMESTAMP = /^((?:\\d{1,}:)?\\d{1,2}:\\d{1,2}[,.]\\d{1,3}) --> ((?:\\d{1,}:)?\\d{1,2}:\\d{1,2}[,.]\\d{1,3})(?: (.*))?$/\n\nexport function parseTimestamps(value: string): Timestamp {\n  const match = RE_TIMESTAMP.exec(value)\n\n  if (!match) {\n    throw new Error('Invalid timestamp format')\n  }\n\n  const timestamp: Timestamp = {\n    start: parseTimestamp(match[1]),\n    end: parseTimestamp(match[2])\n  }\n\n  if (match[3]) {\n    timestamp.settings = match[3]\n  }\n\n  return timestamp\n}\n","import { FormatOptions, Node, Cue, formatTimestamp } from '.'\n\nexport class Formatter {\n  private options: FormatOptions\n  private isVTT: boolean\n  private hasReceivedHeader: boolean\n  private index: number\n\n  constructor(options: FormatOptions) {\n    this.options = options\n    this.hasReceivedHeader = false\n    this.isVTT = options.format === 'WebVTT'\n    this.index = 1\n  }\n\n  public format(node: Node): string {\n    let buffer = ''\n\n    if (node.type === 'header' && this.isVTT) {\n      this.hasReceivedHeader = true\n      buffer += `${node.data}\\n\\n`\n    }\n\n    if (node.type === 'cue') {\n      if (!this.hasReceivedHeader && this.isVTT) {\n        this.hasReceivedHeader = true\n        buffer += 'WEBVTT\\n\\n'\n      }\n\n      buffer += this.formatCue(node.data, this.index++, this.options)\n    }\n\n    return buffer\n  }\n\n  private formatCue(cue: Cue, index: number, options: FormatOptions) {\n    return [\n      `${index > 1 ? '\\n' : ''}${index}`,\n      `${formatTimestamp(cue.start, options)} --> ${formatTimestamp(\n        cue.end,\n        options\n      )}${\n        options.format === 'WebVTT' && cue.settings ? ' ' + cue.settings : ''\n      }`,\n      cue.text,\n      ''\n    ].join('\\n')\n  }\n}\n","import { Node } from '.'\nimport { Transform } from 'readable-stream'\n\nexport const filter = (callback: (node: Node) => boolean) =>\n  new Transform({\n    objectMode: true,\n    transform: function transform(chunk, _encoding, next) {\n      callback(chunk) ? next(null, chunk) : next()\n    }\n  })\n","import multipipe from 'multipipe'\nimport split2 from 'split2'\nimport { createDuplex } from './utils'\nimport { Parser } from './Parser'\n\nexport const parse = () => {\n  const parser = new Parser({\n    push: node => outputStream.push(node)\n  })\n\n  const stream = createDuplex({\n    write(chunk: object, _encoding: string, next: Function) {\n      try {\n        parser.parseLine(chunk.toString())\n      } catch (err) {\n        return next(err)\n      }\n\n      next()\n    }\n  })\n\n  const splitStream = split2()\n\n  splitStream.on('finish', () => {\n    parser.flush()\n    stream.push(null)\n  })\n\n  const outputStream = multipipe(splitStream, stream, {\n    objectMode: true\n  })\n\n  return outputStream\n}\n","import { Parser } from './Parser'\nimport { NodeList } from '.'\n\nexport const parseSync = (input: string): NodeList => {\n  const buffer: NodeList = []\n  const parser = new Parser({\n    push: node => buffer.push(node)\n  })\n\n  input\n    .replace(/\\r\\n/g, '\\n')\n    .split('\\n')\n    .forEach(line => parser.parseLine(line))\n\n  parser.flush()\n\n  return buffer\n}\n","import { map, Node } from '.'\n\nexport const resync = (time: number) =>\n  map((node: Node) => {\n    if (node.type === 'cue') {\n      return {\n        ...node,\n        data: {\n          ...node.data,\n          start: node.data.start + time,\n          end: node.data.end + time\n        }\n      }\n    }\n\n    return node\n  })\n","import { map, FormatOptions, Node } from '.'\nimport { Formatter } from './Formatter'\n\nexport const stringify = (options: FormatOptions) => {\n  const formatter = new Formatter(options)\n  return map((chunk: Node) => formatter.format(chunk))\n}\n","import { NodeList, FormatOptions } from '.'\nimport { Formatter } from './Formatter'\n\nexport const stringifySync = (\n  list: NodeList,\n  options: FormatOptions\n): string => {\n  const formatter = new Formatter(options)\n\n  return list.reduce((buffer, node) => {\n    return buffer + formatter.format(node)\n  }, '')\n}\n"],"names":["padLeft","value","length","toString","padStart","formatTimestamp","timestamp","options","format","date","Date","hours","getHours","minutes","getMinutes","seconds","getSeconds","ms","Math","floor","map","mapper","index","Transform","objectMode","transform","chunk","_encoding","callback","Parser","push","state","expect","row","hasContentStarted","isWebVTT","node","buffer","isIndex","line","test","trim","isTimestamp","RE_TIMESTAMP","isVttComment","getError","expected","Error","parseLine","contents","this","stripBom","header","parseHeader","id","parseId","parseTimestamp","text","parseText","vtt_comment","parseVttComment","call","flush","pushNode","type","data","parseTimestamps","pop","includes","shift","join","match","parseInt","exec","start","end","settings","Formatter","hasReceivedHeader","isVTT","formatCue","cue","next","parser","outputStream","stream","Duplex","read","write","err","splitStream","split2","on","multipipe","input","replace","split","forEach","time","formatter","list","reduce"],"mappings":"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"}