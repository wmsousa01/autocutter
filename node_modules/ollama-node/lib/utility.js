"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamingPost = exports.requestPost = exports.requestDelete = exports.requestShowInfo = exports.requestList = void 0;
const http_1 = require("http");
function requestList(options) {
    return new Promise((resolve, reject) => {
        const req = (0, http_1.request)(options, (response) => {
            const statusCode = response.statusCode || 0;
            if (statusCode < 200 || statusCode > 299) {
                return reject(new Error(`Failed with status code: ${response.statusCode}`));
            }
            const body = [];
            response.on('data', (chunk) => body.push(chunk));
            response.on('end', () => {
                const joined = body.join('');
                const parsed = JSON.parse(joined);
                resolve(parsed);
            });
        });
        req.on('error', reject);
        req.end();
    });
}
exports.requestList = requestList;
;
function requestShowInfo(options, model) {
    return new Promise((resolve, reject) => {
        const req = (0, http_1.request)(options, (response) => {
            const statusCode = response.statusCode || 0;
            if (statusCode < 200 || statusCode > 299) {
                return reject(new Error(`Failed with status code: ${response.statusCode}`));
            }
            const body = [];
            response.on('data', (chunk) => body.push(chunk));
            response.on('end', () => {
                const joined = body.join('');
                const parsed = JSON.parse(joined);
                resolve(parsed);
            });
        });
        req.write(JSON.stringify({ "name": model }));
        req.on('error', reject);
        req.end();
    });
}
exports.requestShowInfo = requestShowInfo;
function requestDelete(options, model) {
    return new Promise((resolve, reject) => {
        const req = (0, http_1.request)(options, (response) => {
            // console.log(response);
            const statusCode = response.statusCode || 0;
            if (statusCode < 200 || statusCode > 299) {
                return reject(new Error(`Failed with status code: ${response.statusCode}`));
            }
            const body = [];
            response.on('data', (chunk) => body.push(chunk));
            response.on('end', () => {
                const joined = body.join('');
                const parsed = JSON.parse(joined);
                resolve(parsed);
            });
        });
        req.write('{"name": "' + model + '"}');
        req.on('error', reject);
        req.end();
    });
}
exports.requestDelete = requestDelete;
function requestPost(target, options, databody) {
    let body = [];
    return new Promise((resolve, reject) => {
        const req = (0, http_1.request)(options, (response) => {
            const statusCode = response.statusCode || 0;
            if (statusCode < 200 || statusCode > 299) {
                return reject(new Error(`Failed with status code: ${response.statusCode}`));
            }
            response.on('data', (chunk) => {
                if (target === 'embed') {
                    // console.log('hi');
                    body.push(chunk.toString('utf8'));
                }
                else {
                    body.push(JSON.parse(chunk));
                }
            });
            response.on('end', () => {
                if (target === 'embed') {
                    resolve({ messages: [], final: JSON.parse(body.join('')) });
                }
                else {
                    const final = body[body.length - 1];
                    const messages = body.splice(0, body.length - 1);
                    resolve({ messages, final });
                }
            });
        });
        req.write(JSON.stringify(databody));
        req.on('error', reject);
        req.end();
    });
}
exports.requestPost = requestPost;
function streamingPost(target, options, databody, callback) {
    const req = (0, http_1.request)(options, (res) => {
        res.on('data', (chunk) => {
            // console.log('in streamingPost');
            // console.log(chunk);
            const chunkStr = chunk.toString();
            const items = chunkStr.split('\n').filter(Boolean);
            for (const item of items) {
                callback(item);
                if (item.includes('error')) {
                    console.log(`Error: ${JSON.parse(item).error}`);
                }
            }
        });
        res.on('error', (error) => {
            console.error(`Response error: ${error.message}`);
        });
        res.on('end', () => {
        });
    });
    req.on('error', (error) => {
        console.error(`Request error: ${error.message}`);
    });
    // Send the POST data
    req.write(JSON.stringify(databody));
    req.end();
}
exports.streamingPost = streamingPost;
// export async function* streamingGenerate(options: RequestOptions, model: string, prompt: string, system: string, template: string, parameters: string): AsyncGenerator<any, any, unknown> {
//   const body: GenerateMessage[] = [];
//   const req = request(options);
//   req.write(JSON.stringify({ "prompt": prompt, "model": model, "system": system, "template": template, "parameters": parameters }));
//   const response: IncomingMessage = await new Promise((resolve, reject) => {
//     req.on('response', resolve);
//     req.on('error', reject);
//     req.end();
//   });
//   for await (const chunk of response) {
//     body.push(JSON.parse(chunk));
//     yield JSON.parse(chunk);
//   }
// }
//# sourceMappingURL=utility.js.map