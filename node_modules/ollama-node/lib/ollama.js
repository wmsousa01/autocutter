"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ollama = void 0;
const utility_1 = require("./utility");
class Ollama {
    Host;
    Port = 11434;
    Model = '';
    SystemPrompt = '';
    Template = '';
    Parameters = {};
    Context = [];
    JSONFormat = false;
    constructor(...args) {
        if (args.length === 0) {
            this.Host = '127.0.0.1';
        }
        else {
            if (args[0] === 'localhost') {
                this.Host = "127.0.0.1";
            }
            else {
                this.Host = args[0];
            }
        }
    }
    numberIfNumber(value) {
        const isOnlyNumbers = /^\d+$/.test(value);
        if (isOnlyNumbers) {
            return parseInt(value, 10);
        }
        return value;
    }
    async parseParams() {
        let options = {};
        const info = await this.showModelInfo();
        const params = info.parameters?.split('\n').forEach(line => {
            const [name, value] = line.split(/\s+/).filter(Boolean);
            const parsedvalue = this.numberIfNumber(value);
            if (name === 'stop') {
                if (!options.stop) {
                    options.stop = [];
                }
                options.stop.push(parsedvalue);
            }
            else {
                options[name] = parsedvalue;
            }
        });
        return options;
    }
    async localModelExists(model) {
        const localmodels = await this.listModels();
        if (model.includes(":")) {
            return localmodels.models.includes(model);
        }
        else {
            const basemodels = localmodels.models.map(m => m.split(":")[0]);
            return basemodels.includes(model);
        }
    }
    setContext(context) {
        this.Context = context;
    }
    showHost() {
        return this.Host;
    }
    setJSONFormat(useJSON) {
        this.JSONFormat = useJSON;
    }
    async setModel(model) {
        if (await this.localModelExists(model)) {
            this.Model = model;
            const info = await this.showModelInfo();
            this.Parameters = await this.parseParams();
            this.Template = info.template || '';
            this.SystemPrompt = info.system || '';
        }
        else {
            throw new Error(`Model ${model} not found.`);
        }
    }
    setTemplate(template) {
        this.Template = template;
    }
    setSystemPrompt(systemPrompt) {
        this.SystemPrompt = systemPrompt;
    }
    addParameter(name, value) {
        name = name.toLowerCase();
        if (name === 'stop') {
            if (!this.Parameters.stop) {
                this.Parameters.stop = [];
            }
            this.Parameters.stop.push(value);
        }
        else {
            this.Parameters[name] = value;
        }
    }
    deleteParameter(name, value) {
        if (name === 'stop') {
            const stops = this.Parameters.stop;
            if (stops.includes(value)) {
                stops.splice(stops.indexOf(value));
                this.Parameters.stop = stops;
            }
        }
        else {
            this.Parameters[name] = undefined;
        }
    }
    deleteParameterByName(name) {
        this.Parameters[name] = undefined;
    }
    deleteAllParameters() {
        this.Parameters = {};
    }
    showParameters() {
        return this.Parameters;
    }
    async showSystemPrompt() {
        return this.SystemPrompt;
    }
    showTemplate() {
        return this.Template;
    }
    showModel() {
        return this.Model;
    }
    async showModelInfo() {
        const options = {
            hostname: this.Host,
            port: this.Port,
            method: 'POST',
            path: '/api/show'
        };
        return await (0, utility_1.requestShowInfo)(options, this.Model);
    }
    async listModels() {
        const options = {
            hostname: this.Host,
            port: this.Port,
            path: '/api/tags',
            method: 'GET'
        };
        const getResponse = await (0, utility_1.requestList)(options);
        const complete = getResponse.models;
        const models = complete.map(m => m.name);
        return { models, complete };
    }
    async generate(prompt) {
        const generateOptions = {
            hostname: this.Host,
            port: 11434,
            method: 'POST',
            path: '/api/generate',
        };
        const body = {
            model: this.Model,
            prompt,
            system: this.SystemPrompt,
            template: this.Template,
            options: this.Parameters,
            context: this.Context
        };
        if (this.JSONFormat) {
            body.format = "json";
        }
        let genoutput, final, messages;
        try {
            genoutput = await (0, utility_1.requestPost)('generate', generateOptions, body);
            final = genoutput.final;
            messages = genoutput.messages;
        }
        catch (error) {
            console.log(`There was a problem generating output from ${this.Model} with the prompt ${prompt}: ${error}`);
            return { output: "", stats: {} };
        }
        // const final: GenerateFinalOutput = genoutput.final as GenerateFinalOutput;
        // const messages: GenerateMessage[] = genoutput.messages as GenerateMessage[];
        this.Context = final.context;
        const output = messages.map(m => m.response).join("");
        return { output, stats: final };
    }
    ;
    streamingGenerate(prompt, responseOutput = null, contextOutput = null, fullResponseOutput = null, statsOutput = null) {
        return new Promise((resolve, reject) => {
            const options = {
                hostname: this.Host,
                port: 11434,
                method: 'POST',
                path: '/api/generate',
            };
            const body = {
                model: this.Model,
                prompt,
                system: this.SystemPrompt,
                template: this.Template,
                options: this.Parameters,
                context: this.Context
            };
            if (this.JSONFormat) {
                body.format = "json";
            }
            (0, utility_1.streamingPost)('generate', options, body, (chunk) => {
                const jchunk = JSON.parse(chunk);
                if (Object.hasOwn(jchunk, 'response')) {
                    fullResponseOutput && fullResponseOutput(JSON.stringify(jchunk));
                    responseOutput && responseOutput(jchunk.response);
                }
                else {
                    if (Object.hasOwn(jchunk, 'context')) {
                        statsOutput && statsOutput(JSON.stringify(jchunk));
                        contextOutput && contextOutput(jchunk.context.toString());
                        this.Context = jchunk.context;
                        resolve();
                    }
                }
            });
        });
    }
    // async delete(modelName: string) {
    //   const options: RequestOptions = {
    //     hostname: this.Host,
    //     port: 11434,
    //     method: 'DELETE',
    //     path: '/api/delete',
    //   }
    //   const genoutput = await requestDelete(options, modelName);
    //   console.log(genoutput);
    // }
    async create(modelName, modelPath) {
        const createOptions = {
            hostname: this.Host,
            port: 11434,
            method: 'POST',
            path: '/api/create',
        };
        const createBody = {
            name: modelName,
            path: modelPath
        };
        const genoutput = await (0, utility_1.requestPost)('create', createOptions, createBody);
        const messages = genoutput.messages;
        return messages.map(m => m.status);
    }
    ;
    async generateEmbed(modelName, input) {
        const options = {
            hostname: this.Host,
            port: 11434,
            method: 'POST',
            path: '/api/embeddings'
        };
        const body = {
            model: modelName,
            prompt: input
        };
        const genoutput = await (0, utility_1.requestPost)('embed', options, body);
        return genoutput.final.embedding;
    }
    ;
    streamingCreate(modelName, modelPath, responseOutput = null) {
        return new Promise((resolve, reject) => {
            const options = {
                hostname: this.Host,
                port: 11434,
                method: 'POST',
                path: '/api/create',
            };
            const body = {
                name: modelName,
                path: modelPath
            };
            (0, utility_1.streamingPost)('create', options, body, async (chunk) => {
                const jchunk = JSON.parse(chunk);
                if (Object.hasOwn(jchunk, 'status')) {
                    responseOutput && responseOutput(jchunk.status);
                    if (jchunk.status === "success") {
                        resolve();
                    }
                }
                else {
                    responseOutput && responseOutput(jchunk);
                }
            });
        });
    }
    async streamingPull(modelName, responseOutput = null) {
        return new Promise((resolve, reject) => {
            const options = {
                hostname: this.Host,
                port: 11434,
                method: 'POST',
                path: '/api/pull',
            };
            const body = {
                name: modelName
            };
            (0, utility_1.streamingPost)('pull', options, body, async (chunk) => {
                const jchunk = JSON.parse(chunk);
                let percent = "";
                if (Object.hasOwn(jchunk, 'completed')) {
                    percent = `downloading - ${(100 * (jchunk.completed / jchunk.total)).toFixed(2)} % complete`;
                    responseOutput && responseOutput(`${percent}`);
                }
                else if (Object.hasOwn(jchunk, 'status')) {
                    responseOutput && responseOutput(jchunk.status);
                    // if (jchunk.status === "success") {
                    //   resolve();
                    // }
                }
                else {
                    responseOutput && responseOutput(jchunk);
                }
                if (jchunk.status === "success") {
                    resolve();
                }
            });
        });
    }
    async streamingPush(modelName, responseOutput = null) {
        return new Promise((resolve, reject) => {
            const options = {
                hostname: this.Host,
                port: 11434,
                method: 'POST',
                path: '/api/push',
            };
            const body = {
                name: modelName
            };
            (0, utility_1.streamingPost)('push', options, body, async (chunk) => {
                const jchunk = JSON.parse(chunk);
                if (Object.hasOwn(jchunk, 'status')) {
                    responseOutput && responseOutput(jchunk.status);
                    // if (jchunk.status === "success") {
                    //   resolve();
                    // }
                }
                else {
                    responseOutput && responseOutput(jchunk);
                }
            });
        });
    }
    async copy(sourceName, destinationName) {
        const options = {
            hostname: this.Host,
            port: 11434,
            method: 'POST',
            path: '/api/copy',
        };
        const body = {
            source: sourceName,
            destination: destinationName
        };
        if (await this.localModelExists(sourceName)) {
            (0, utility_1.requestPost)('copy', options, body);
        }
        else {
            return Promise.reject(new Error("Model not found"));
        }
    }
    ;
    cbPrintword(chunk) {
        process.stdout.write(chunk);
    }
    cbPrintLine(chunk) {
        console.log(chunk);
    }
}
exports.Ollama = Ollama;
//# sourceMappingURL=ollama.js.map