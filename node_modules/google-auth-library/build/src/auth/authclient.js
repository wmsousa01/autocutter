"use strict";
// Copyright 2012 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthClient = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = exports.DEFAULT_UNIVERSE = void 0;
const events_1 = require("events");
const gaxios_1 = require("gaxios");
const util_1 = require("../util");
const shared_cjs_1 = require("../shared.cjs");
/**
 * The default cloud universe
 *
 * @see {@link AuthJSONOptions.universe_domain}
 */
exports.DEFAULT_UNIVERSE = 'googleapis.com';
/**
 * The default {@link AuthClientOptions.eagerRefreshThresholdMillis}
 */
exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1000;
class AuthClient extends events_1.EventEmitter {
    apiKey;
    projectId;
    /**
     * The quota project ID. The quota project can be used by client libraries for the billing purpose.
     * See {@link https://cloud.google.com/docs/quota Working with quotas}
     */
    quotaProjectId;
    /**
     * The {@link Gaxios `Gaxios`} instance used for making requests.
     */
    transporter;
    credentials = {};
    eagerRefreshThresholdMillis = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS;
    forceRefreshOnFailure = false;
    universeDomain = exports.DEFAULT_UNIVERSE;
    constructor(opts = {}) {
        super();
        const options = (0, util_1.originalOrCamelOptions)(opts);
        // Shared auth options
        this.apiKey = opts.apiKey;
        this.projectId = options.get('project_id') ?? null;
        this.quotaProjectId = options.get('quota_project_id');
        this.credentials = options.get('credentials') ?? {};
        this.universeDomain = options.get('universe_domain') ?? exports.DEFAULT_UNIVERSE;
        // Shared client options
        this.transporter = opts.transporter ?? new gaxios_1.Gaxios(opts.transporterOptions);
        if (options.get('useAuthRequestParameters') !== false) {
            this.transporter.interceptors.request.add(AuthClient.DEFAULT_REQUEST_INTERCEPTOR);
        }
        if (opts.eagerRefreshThresholdMillis) {
            this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis;
        }
        this.forceRefreshOnFailure = opts.forceRefreshOnFailure ?? false;
    }
    /**
     * Sets the auth credentials.
     */
    setCredentials(credentials) {
        this.credentials = credentials;
    }
    /**
     * Append additional headers, e.g., x-goog-user-project, shared across the
     * classes inheriting AuthClient. This method should be used by any method
     * that overrides getRequestMetadataAsync(), which is a shared helper for
     * setting request information in both gRPC and HTTP API calls.
     *
     * @param headers object to append additional headers to.
     */
    addSharedMetadataHeaders(headers) {
        // quota_project_id, stored in application_default_credentials.json, is set in
        // the x-goog-user-project header, to indicate an alternate account for
        // billing and quota:
        if (!headers.has('x-goog-user-project') && // don't override a value the user sets.
            this.quotaProjectId) {
            headers.set('x-goog-user-project', this.quotaProjectId);
        }
        return headers;
    }
    /**
     * Adds the `x-goog-user-project` and `authorization` headers to the target Headers
     * object, if they exist on the source.
     *
     * @param target the headers to target
     * @param source the headers to source from
     * @returns the target headers
     */
    addUserProjectAndAuthHeaders(target, source) {
        const xGoogUserProject = source.get('x-goog-user-project');
        const authorizationHeader = source.get('authorization');
        if (xGoogUserProject) {
            target.set('x-goog-user-project', xGoogUserProject);
        }
        if (authorizationHeader) {
            target.set('authorization', authorizationHeader);
        }
        return target;
    }
    static DEFAULT_REQUEST_INTERCEPTOR = {
        resolved: async (config) => {
            // Set `x-goog-api-client`, if not already set
            if (!config.headers.has('x-goog-api-client')) {
                const nodeVersion = process.version.replace(/^v/, '');
                config.headers.set('x-goog-api-client', `gl-node/${nodeVersion}`);
            }
            // Set `User-Agent`
            const userAgent = config.headers.get('User-Agent');
            if (!userAgent) {
                config.headers.set('User-Agent', shared_cjs_1.USER_AGENT);
            }
            else if (!userAgent.includes(`${shared_cjs_1.PRODUCT_NAME}/`)) {
                config.headers.set('User-Agent', `${userAgent} ${shared_cjs_1.USER_AGENT}`);
            }
            return config;
        },
    };
    /**
     * Retry config for Auth-related requests.
     *
     * @remarks
     *
     * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
     * config as some downstream APIs would prefer if customers explicitly enable retries,
     * such as GCS.
     */
    static get RETRY_CONFIG() {
        return {
            retry: true,
            retryConfig: {
                httpMethodsToRetry: ['GET', 'PUT', 'POST', 'HEAD', 'OPTIONS', 'DELETE'],
            },
        };
    }
}
exports.AuthClient = AuthClient;
//# sourceMappingURL=authclient.js.map